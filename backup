#! /usr/bin/env python
import gtk, pygtk, sys, argparse, time, datetime
import pynotify, os, signal, shutil, subprocess
import ConfigParser
from backuplib import *

hier = ['hourly','daily','weekly','monthly']
retain = [24,7,4,12]
WD_dir = '/media/Backups/snapshots/'
root_exclusions = ['/home/kevin/.local/share/Trash/','*/*cache*','*/*wine*','*/*windows/','/dev','/proc','/mnt','/sys','/media','/run','/Windows','/home/kevin/.config/chromium','/home/kevin/.macromedia','*/*Cache*','/home/kevin/.dolphin-emu']
logf1 = '/home/kevin/.log'
logf2 = '/home/kevin/.logall'

#==============================================================================================================================================

def notification(string,icon):
	n = pynotify.Notification("Backup",string,icon)
	n.set_urgency(pynotify.URGENCY_CRITICAL)
	n.show()
	return

def onexit():
	notification('The backup has encountered a fatal encounter and has been forced to exit. Check the logfile for further details.','dialog-error')
	exit()

def execute(cmd):
	process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
	
	while True:
		nextline = process.stdout.readline()
		if nextline == '' and process.poll() != None: break
		sys.stdout.write(nextline)

	output = process.communicate()[0]
	returncode = process.returncode

	if (returncode == 0): return output
	else: raise ProcessError(cmd, returncode, output)

def rsync(source,back_dir,log,sudo,excludes=[]):
	for src in source:
		params = []
		if sudo:
			params = ['gksudo']
		log.log('Syncing: ' + src)
		params += '/usr/bin/rsync -avvx --numeric-ids --relative --delete --delete-excluded'.split()
		for exclude in excludes: params.append('--exclude='+exclude)
		params.append(src)
		params.append(back_dir+'hourly.00/')

		try: print execute(params)
		except ProcessError as e:
			log.log('ERROR: could not execute {0}: exited with return code {1}.\n\t{2}'.format(e.cmd,e.returncode,e.output))
	return

def name_strip(name,direc,log):
	try: files = os.listdir(direc)
	except OSError as e:
		log.log('ERROR: Could not list files in {0}. Error number {1}.\n\t{2}'.format(e.filename,e.errno,e.strerror))
		onexit()
	else:
		cyc = []
		for n in files:
			if name in n:
				time = n[len(name)+1:]
				try: time = int(time)
				except ValueError: log.log('Could not convert ' + n + ' to integer; skipped.')
				else: cyc.append(time)
		return sorted(cyc,reverse=True)

#===============================================================================================================================================#
#===============================================================================================================================================#
#                                                                                                                                               #
#                                                                                                                                               #
#                                                                                                                                               #
#===============================================================================================================================================#
#===============================================================================================================================================#

def cycle(hierarchy,loc,retention,source,back_dir,log,to_exclude=[]):
	log.log('Staring backup...')
	if loc >= len(hierarchy) or loc < 0:
		log.log('Error in running parameters.')
		log.log(hierarchy); log.log(loc); log.log(retention)
		return

	last = 0
	try:
		log.log('Reading history file...')
		f = open(back_dir+'.hist','r+')
		hist = f.readlines()
		f.close()
		last = int(hist[loc].strip())
	except IOError as e:
		log.log('ERROR: Could not read history file ({0}).\n\t{1}'.format(e.errno, e.strerror))
	except ValueError:
		log.log('Error reading history file: incorrect input for integer.')

	else:
		log.log(str(last) +' ' + hierarchy[loc] + ' backups.')
		if last == retention[loc] and loc < len(hierarchy)-1:
			log.log('Retention reached; moving one step up the hierarchy.')
			hist[loc] = '0'
			with open(back_dir+'.hist','w') as f:
				for l in hist: f.write(l.strip() + '\n')
			cycle(hierarchy,loc+1,retention,source,back_dir,log,to_exclude)
		else:
			names = name_strip(hierarchy[loc],back_dir,log)
			if 00 in names:
				if note > 1:
					notification('Cycling backups up...','dialog-info')
				log.log('Renaming files...')
				for name in names:
					fro = back_dir+hierarchy[loc]+'.'+str(name).zfill(2)+'/'
					to = back_dir+hierarchy[loc]+'.'+str(name+1).zfill(2)+'/'
					try: print execute(['/bin/mv', fro, to])
					except ProcessError as e:
						log.log('ERROR: Could not cycle backups. Command {0} failed with code {1}.\n{2}'.format(e.cmd,e.returncode,e.output))
						onexit()

			if hierarchy[loc] == 'hourly':
				if note > 1:
					notification('Copying newest backup directory...','dialog-info')

				log.log('Preparing new backup directory...')
				if os.path.exists(back_dir+'hourly.'+str(retention[loc]).zfill(2)):
					try: print execute(['/bin/mv', back_dir+'hourly.'+str(retention[loc]-1).zfill(2),back_dir+'hourly.00'])
					except ProcessError as e:
						log.log('ERROR: Moving old backup failed: exited with return code {0}.\n{1}'.format(e.returncode,e.output))
					else: log.log('Backup moved successfully.')

				elif os.path.exists(back_dir+'hourly.01'):
					log.log('Good to go! Copying now.')
					try:
						print execute(['/bin/cp','-val',back_dir+'hourly.01',back_dir+'hourly.00'])
					except ProcessError as e:
						log.log('ERROR: Copying backup failed: exited with return code {0}.\n\t{1}'.format(e.returncode,e.output))

				else:
					log.log('Creating new backup directory...')

				if note > 1:
					notification('Executing rsync...','dialog-info')

				rsync(source,back_dir,log,sudo,to_exclude)

				if os.path.exists(back_dir+'hourly.00'):
					log.log('rsync executed successfully.')
				else:
					log.log('ERROR: rsync was not successful.')
					try: os.mkdir(back_dir+'hourly.00')
					except OSError: log.log('ERROR: could not create empty dir; next backup will fail.')
					notification('rsync failed; please correct any errors manually.','dialog-error')
			else:
				if note > 1:
					notification('Copying latest ' + hierarchy[loc-1] + ' backup...','dialog-info')
				log.log('Using most recent backup from one step down...')
				if os.path.exists(back_dir+hierarchy[loc-1]+'.'+str(retention[loc-1]-1).zfill(2)):
					log.log('Renaming backup...')
					try: execute(['mv',back_dir+hierarchy[loc-1]+'.'+str(retention[loc-1]-1).zfill(2),back_dir+hierarchy[loc]+'.00'])
					except ProcessError as e:
						log.log('ERROR: could not cycle new ' + hierarchy[loc] +\
						' backup ({0}): {1} failed.\n\t{2}'.format(e.returncode,e.cmd,e.output))
						notification('Unable to cycle backups; please correct any errors manually.','dialog-error')

			if os.path.exists(back_dir+hierarchy[loc]+'.'+str(retention[loc]).zfill(2)):
				if note > 1:
					notification('Removing old backups...','dialog-info')
				log.log('Removing old backups...')
				try: shutil.rmtree(back_dir+hierarchy[loc]+'.'+str(retention[loc]).zfill(2))
				except OSError as e:
					log.log('ERROR: Could not remove {0} ({1}).\n\t{2}'.format(e.filename,e.errno,e.strerror))
					notification('Unable to remove old backup; please delete manually.','dialog-error')

			hist[loc] = str(last+1)

			with open(back_dir+'.hist','w') as f:
				for l in hist: f.write(l.strip() + '\n')
	return

#==============================================================================================================================================
#	confirm(t) will prompt the user to insert the backup medium.
#==============================================================================================================================================

def confirm(t,back_dir,log):
	log.log('Checking for backup directory.')
	timetill = str(datetime.timedelta(seconds=t)).zfill(8)
	if timetill[0] + timetill[1] + timetill[3] == '000':
		timetill = timetill[4:]

#	if os.path.exists('/tmp/backup.pid'):
	if clobber.exists() or clobber.locked():
		log.log('Backup already in progress. Please try again later.')
		notification('Backup already in progress. Please try again later.','dialog-error')
		exit()

	notification(action.title() + ' backup is scheduled to run in ' +\
		 timetill + '. Please ensure that the backup device is connected.','dialog-warning')
#	with open('/tmp/backup.pid','w') as f: f.write(str(os.getpid()))
	clobber.make()
	time.sleep(t)
	log.log('About to check...')
	if not (os.path.exists(back_dir)):
		log.log('Staring dialog...')

		dialog = gtk.MessageDialog(None, 0, gtk.MESSAGE_QUESTION, gtk.BUTTONS_OK,\
			action.title() + ' backup is scheduled to run. Is the backup device mounted at ' + back_dir + '?')
		dialog.run()

		if not os.path.exists(back_dir):
			dialog_response = 0
			log.log('Starting second dialog...')
			dialog.destroy()
			dialog = gtk.MessageDialog(None,0,gtk.MESSAGE_INFO,gtk.BUTTONS_OK_CANCEL,'Please mount the device now.')
			dialog_response = dialog.run()

			if dialog_response != -5 or not os.path.exists(back_dir):
				notification(action.title() + ' backup failed: unable to locate backup device. Please try again later.','dialog-error')
				exit()
		dialog.destroy()
	else:
		notification(action.title() + ' backup is now running. Please do not remove backup device.','dialog-warning')
		try: clobber.lock()#os.rename('/tmp/backup.pid','/tmp/backup_lock.pid')
		except OSError as e: log.log('ERROR: could not rename lockfile {0} ({1}).\n\t{2}'.format(e.filename,e.errno,e.strerror))
	return

#==============================================================================================================================================

log = logger(logf1, logf2)
clobber = clobber(['/run/backup.pid','/tmp/backup.pid'],'/var/lock/backup.lock',log)

try: os.remove(logf2)
except OSError as e: log.log("Couldn't remove last log2 file.\n{0}".format(e.strerror))
log.log(str(datetime.datetime.now()))

sys.stdout = log
sys.stderr = log

pynotify.init('Backup')

#parser = argparse.ArgumentParser()
#parser.add_argument('action',action='store')
#parser.add_argument('-t',action='store',type=int,default=120)
#parser.add_argument('-n',action='store',type=int,default=1)
#parser.add_argument('-s',action='store_true',default=False)

#args = parser.parse_args(sys.argv[1:]).__dict__
#action = args['action']
#t = args['t']
#note = args['n']
#sup = args['s']

config = ConfigParser.ConfigParser()
config.read(['/home/kevin/bin/backup.conf'])

WD_dir = config.get('backup','directory')
#print config.get('backup','exclusions').split('\n')
t = config.get('backup','time')
note = config.get('backup','verbosity')
logf1 = config.get('backup','shortlog')
logf2 = config.get('backup','longlog')
struc = config.items('retain')
hier = [a[0] for a in ret]
retain = [int(a[1]) for a in ret]
root_exclusions = [a[1] for a in config.items('exclusions')]
exit()

if sup:
	execute(['gksudo',sys.argv[0],sys.argv[1]])
	exit()

if action in hier:
	confirm(t,WD_dir,log)
	cycle(hier,hier.index(action),retain,['/'],WD_dir,log,root_exclusions)

elif action == 'test':
	log.log('testing...')
	confirm(t,WD_dir,log,sup)
	cycle(hier,0,[4,2,2,2],['/home/kevin/test/'],'/media/Backups/test/',log,sup,['*/*wine*','*/*windows*'])

elif action == 'kill':
	log.log('killing...')
#	if os.path.exists('/tmp/backup.pid'):
	if clobber.exists():
		try: os.kill(clobber.get(),signal.SIGHUP)
		except OSError as e: log.log('ERROR: could not kill process.')
		notification('The pending backup has been cancelled.','dialog-info')
		exit()
	elif clobber.locked():#os.path.exists('/tmp/backup_lock.pid'):
		notification('Backup is already in progress. Please do not interrupt the process.','dialog-warning')
		exit()
	else:
		notification('No backup in progress. Are you sure one is running?','dialog-question')
		log.log('Process not found.')
		exit()

else:
	log.log(str(sys.argv))
	log.log('Invalid option.')
	exit()

notification(action.title() + " backup is complete.",'dialog-info')
try: clobber.remove()#os.remove('/tmp/backup_lock.pid')
except OSError as e: log.log('ERROR: Could not remove lockfile {0} ({1}).\n\t{2}'.format(e.filename,e.errno,e.strerror))
