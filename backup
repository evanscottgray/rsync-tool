#! /usr/bin/env python
import gtk, pygtk, sys, argparse, time
import pynotify, os, signal, shutil, subprocess

heirarchy = ['hourly','daily','weekly','monthly']
retention = [4,7,4,12]
back_dir = '/media/WD/Backups/kevin/'

class logger(object):
	def write(self,data):
		f = open('/home/kevin/.log','a')
		f.write(data)
		f.close()

#sys.stdout = logger()
#sys.stderr = logger()

def notification(string,icon):
	n = pynotify.Notification("Backup",string,icon)
	n.set_urgency(pynotify.URGENCY_CRITICAL)
	n.show()
	return

def onexit():
	notification('The backup has encountered a fatal encounter and has been forced to exit. Check the logfile for further details.','dialog-error')
	exit()

def ProcessError(Exception):
	def __init__(self, cmd, returncode, output):
		self.cmd = cmd
		self.returncode = returncode
		self.output = output
	def __str__(self, cmd, returncode, output):
		return repr('Process ' + cmd + ' failed with code ' + returncode + '.\n' + output)

def execute(cmd):
	process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
	
	while True:
		nextline = process.stdout.readline()
		if nextline == '' and process.poll() != None:
				break
		sys.stdout.write(nextline)
		sys.stdout.flush()

	output = process.communicate()[0]
	returncode = process.returncode

	if (returncode == 0):
		return output
	else:
		raise ProcessError(cmd, returncode, output)

def rsync(source,excludes=None):
	print 'Syncing ' + source
	params = ['/usr/bin/rsync',\
		'-a',\
		'--numeric-ids',\
		'--relative',\
		'--delete-excluded']
	if excludes:
		for exclude in excludes:
			params.append('--exclude='+exclude)
	params.append(source)
	params.append(back_dir+'hourly.00/')

	try: print execute(params)
	except ProcessError as e:
		print 'ERROR: could not execute {0}: exited with return code {1}.\n\t{2}'.format(e.cmd,e.returncode,e.output)
	return

def name_strip(name,loc):
	try: names = os.listdir(loc)
	except OSError as e:
		print 'ERROR: Could not list files in {0}. Error number {1}.\n\t{2}'.format(e.filename,e.errno,e.strerror)
		onexit()
	else:
		cyc = []
		for n in names:
			if name in n:
				time = n[len(name)+1:]
				try: time = int(time)
				except ValueError: print 'Could not convert ' + n + ' to integer; skipped.'
				else: cyc.append(time)
		return sorted(cyc,reverse=True)

def cycle(loc):
	if loc > 3 or loc < 0:
		return

	last = 0
	try:
		print 'Reading history file...'
		f = open(back_dir+'.hist','r+')
		hist = f.readlines()
		f.close()
		last = int(hist[loc].strip())
	except IOError as e:
		print 'ERROR: Could not read history file ({0}).\n\t{1}'.format(e.errno, e.strerror)
		onexit()
	except ValueError:
		print 'Error reading history file: incorrect input for integer.'
		onexit()

	else:
		print last
		if last == retention[loc]:
			print 'Retention reached; moving one step up the hierarchy.'
			cycle(loc+1)
			hist[loc] = '0'
		else:
			names = name_strip(heirarchy[loc],back_dir)
			if 00 in names:
				print 'Renaming files...'
				for name in names:
					fro = back_dir+heirarchy[loc]+'.'+str(name).zfill(2)+'/'
					to = back_dir+heirarchy[loc]+'.'+str(name+1).zfill(2)+'/'
					try: print execute(['/bin/mv', fro, to])
					except ProcessError as e:
						print 'ERROR: Could not cycle backups. Command {0} failed with code {1}.\n{2}'.format(e.cmd,e.returncode,e.output)
						onexit()

			if heirarchy[loc] == 'hourly':
				print 'Copying new backup directory...'
				if os.path.exists(back_dir+'hourly.01'):
					try:
						print execute(['/bin/cp','-val',back_dir+'hourly.01',back_dir+'hourly.00'])
					except ProcessError as e:
						print 'ERROR: Copying backup failed: exited with return code {0}.\n\t{1}'.format(e.returncode,e.output)
						onexit()
				rsync('/home/kevin/',['/home/kevin/.local/share/Trash/','/home/kevin/.cache/'])
				rsync('/usr/local/')
				rsync('/usr/share/')
				rsync('/etc/')
				rsync('/opt/')
				if os.path.exists(back_dir+'hourly.00'):
					print 'rsync executed successfully.'
				else:
					print 'ERROR: rsync was not successful.'
					try: os.mkdir(back_dir+'hourly.00')
					except OSError: print 'ERROR: could not create empty dir; next backup will fail.'
					notification('rsync failed; please correct any errors manually.','dialog-error')
			else:
				print 'Using most recent backup from one step down...'
				if os.path.exists(back_dir+heirarchy[loc-1]+'.'+str(retention[loc-1]-1).zfill(2)):
					print 'Renaming backup...'
					try: execute(['mv',back_dir+heirarchy[loc-1]+'.'+str(retention[loc-1]-1).zfill(2),back_dir+heirarchy[loc]+'.00'])
					except ProcessError as e:
						print 'ERROR: could not cycle new ' + heirarchy[loc] +\
						' backup ({0}): {1} failed.\n\t{2}'.format(e.returncode,e.cmd,e.output)
						notification('Unable to cycle backups; please correct any errors manually.','dialog-error')

			if os.path.exists(back_dir+heirarchy[loc]+'.'+str(retention[loc]).zfill(2)):
				print 'Removing old backups...'
				try: shutil.rmtree(back_dir+heirarchy[loc]+'.'+str(retention[loc]).zfill(2))
				except OSError as e:
					print 'ERROR: Could not remove {0} ({1}).\n\t{2}'.format(e.filename,e.errno,e.strerror)
					notification('Unable to remove old backup; please delete manually.','dialog-error')

			hist[loc] = str(last+1)

		f = open(back_dir+'.hist','w')
		for l in hist:
			f.write(l.strip())
			f.write('\n')
		f.close()
	return

def confirm(t=120):
	timetill = ''
	if t//3600 > 0:
			timetill += str(t//3600) + ' hour'
			if t//3600 > 1:
				timetill += 's'
	if t%3600//60 > 0:
		timetill += ' ' + str(t%3600//60) + ' minute'
		if t%3600//60 > 1:
			timetill += 's'
	if t%60 != 0:
		timetill += ' ' + str(t%60) + ' second'
		if t%60 > 1:
			timetill += 's'

	if os.path.exists('/tmp/backup.pid'):
		print 'Backup already in progress. Please try again later.'
		onexit()

	notification(action.title() + ' backup is scheduled to run in ' + timetill + '. Please ensure that the backup device is connected.','dialog-warning')

	f = open('/tmp/backup.pid','w')
	f.write(str(os.getpid()))
	f.close()
	time.sleep(t)

	if (os.path.exists(back_dir)):
		notification(action.title() + ' backup is now running. Please do not remove backup device.','dialog-warning')
		try: os.rename('/tmp/backup.pid','/tmp/backup_lock.pid')
		except OSError as e: print 'ERROR: could not rename lockfile {0} ({1}).\n\t{2}'.format(e.filename,e.errno,e.strerror)
		return
	dialog_response = 0
	dialog = gtk.MessageDialog(None, gtk.DIALOG_MODAL,\
		gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO,\
		action.title() + ' backup is scheduled to run.' +\
		' Is the backup device mounted at /media/WD?')

	dialog_response = dialog.run()
	dialog.destroy()

	if dialog_response == -8 and os.path.exists(back_dir):
		notification(action.title() + ' backup is now running. Please do not remove backup device.','dialog-warning')
		try: os.rename('/tmp/backup.pid','/tmp/backup_lock.pid')
		except OSError as e: print 'ERROR: could not rename lockfile {0} ({1}).\n\t{2}'.format(e.filename,e.errno,e.strerror)
		return
	else:
		dialog = gtk.MessageDialog(None,0,gtk.MESSAGE_INFO,gtk.BUTTONS_OK_CANCEL,'Please mount the device now.')
		dialog_response = dialog.run()
		dialog.destroy()
		print dialog_response
		if dialog_response == -5 and os.path.exists(back_dir):
			notification(action.title() + ' backup is now running. Please do not remove backup device.','dialog-warning')
			try: os.rename('/tmp/backup.pid','/tmp/backup_lock.pid')
			except OSError as e: print 'ERROR: could not rename lockfile {0} ({1}).\n\t{2}'.format(e.filename,e.errno,e.strerror)
			return
		else:
			notification(action.title() + ' backup failed: unable to locate backup device. Please try again later.','dialog-error')
			exit()
	return

pynotify.init('Backup')
parser = argparse.ArgumentParser()
parser.add_argument('action',action='store')
parser.add_argument('-t',action='store',type=int)

args = parser.parse_args(sys.argv[1:]).__dict__
action = args['action']
t = args['t']

if action in heirarchy:
	confirm(t)
	cycle(heirarchy.index(action))

elif action == 'test':
	print 'testing...'
	confirm(t)

elif action == 'kill':
	print 'killing...'
	if os.path.exists('/tmp/backup.pid'):
		try: os.kill(int(open('/tmp/backup.pid').read().strip()),signal.SIGHUP)
		except OSError as e: print 'ERROR: could not kill process.'
		notification('The pending backup has been cancelled.','dialog-info')
		exit()
	elif os.path.exists('/tmp/backup_lock.pid'):
		notification('Backup is already in progress. Please do not interrupt the process.','dialog-warning')
		exit()
	else:
		notification('No backup in progress. Are you sure one is running?','dialog-question')
		print 'Process not found.'
		exit()

else:
	print 'Invalid option.'
	exit()

notification(action.title() + " backup is complete.",'dialog-info')
try: os.remove('/tmp/backup_lock.pid')
except OSError as e: print 'ERROR: Could not remove lockfile {0} ({1}).\n\t{2}'.format(e.filename,e.errno,e.strerror)
